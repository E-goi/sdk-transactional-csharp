/* 
 * Transactional API
 *
 * # Introduction    This API is a service provided by [E-goi](www.e-goi.com) to send transactional messages.    Transactional Messaging is a 1-to-1 communication channel, usually from an organization directed to a specific consumer.   They can be triggered by:    * __Actions__ - The consumer interacts with the organization (ie.: online shopping);  * __Time__ - The consumer's actions are time-bounded by the organization (ie.: period of inactivity).    Because of the nature of these messages,   it is expected that the consumer is interested in the content of these messages.   Therefore, they have a different treatment from marketing messages, and have a higher acceptance and opening rate.    >DISCLAIMER  >  >Please notice that this platform is more delicate in regards to the nature and processing of its messages.  >  >It should NOT be used as a mean of mass marketing, scams, phishing or overall unruly behaviour.   >  >Failure to comply may lead to limitation of use and even termination of account.    ***
 *
 * OpenAPI spec version: V2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// The message and its triggering condition
    /// </summary>
    [DataContract]
        public partial class MultiChannelMessageObject :  IEquatable<MultiChannelMessageObject>, IValidatableObject
    {
        /// <summary>
        /// The condition of the previous message to trigger the next one. In list of messages in the plan the condition of the first message is discarded (doesnt have previous condition). Can be:  Name | Description | Channel - -- | - -- | - -- none | no condition of previous message | email, sms not_open | previous message hasnt been opened | email open | previous message has been opened | email click | previous message has a link that has been clicked | email not_click | previous message has a link that has not been clicked | email
        /// </summary>
        /// <value>The condition of the previous message to trigger the next one. In list of messages in the plan the condition of the first message is discarded (doesnt have previous condition). Can be:  Name | Description | Channel - -- | - -- | - -- none | no condition of previous message | email, sms not_open | previous message hasnt been opened | email open | previous message has been opened | email click | previous message has a link that has been clicked | email not_click | previous message has a link that has not been clicked | email</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum ConditionEnum
        {
            /// <summary>
            /// Enum None for value: none
            /// </summary>
            [EnumMember(Value = "none")]
            None = 1,
            /// <summary>
            /// Enum Notopen for value: not_open
            /// </summary>
            [EnumMember(Value = "not_open")]
            Notopen = 2,
            /// <summary>
            /// Enum Open for value: open
            /// </summary>
            [EnumMember(Value = "open")]
            Open = 3,
            /// <summary>
            /// Enum Click for value: click
            /// </summary>
            [EnumMember(Value = "click")]
            Click = 4,
            /// <summary>
            /// Enum Notclick for value: not_click
            /// </summary>
            [EnumMember(Value = "not_click")]
            Notclick = 5        }
        /// <summary>
        /// The condition of the previous message to trigger the next one. In list of messages in the plan the condition of the first message is discarded (doesnt have previous condition). Can be:  Name | Description | Channel - -- | - -- | - -- none | no condition of previous message | email, sms not_open | previous message hasnt been opened | email open | previous message has been opened | email click | previous message has a link that has been clicked | email not_click | previous message has a link that has not been clicked | email
        /// </summary>
        /// <value>The condition of the previous message to trigger the next one. In list of messages in the plan the condition of the first message is discarded (doesnt have previous condition). Can be:  Name | Description | Channel - -- | - -- | - -- none | no condition of previous message | email, sms not_open | previous message hasnt been opened | email open | previous message has been opened | email click | previous message has a link that has been clicked | email not_click | previous message has a link that has not been clicked | email</value>
        [DataMember(Name="condition", EmitDefaultValue=false)]
        public ConditionEnum? Condition { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="MultiChannelMessageObject" /> class.
        /// </summary>
        /// <param name="channel">Available communications channels in the API. Currently there are Emails and Sms. (required).</param>
        /// <param name="interval">the interval in seconds between the message and the previous. Defaults to 3600s (1h)..</param>
        /// <param name="condition">The condition of the previous message to trigger the next one. In list of messages in the plan the condition of the first message is discarded (doesnt have previous condition). Can be:  Name | Description | Channel - -- | - -- | - -- none | no condition of previous message | email, sms not_open | previous message hasnt been opened | email open | previous message has been opened | email click | previous message has a link that has been clicked | email not_click | previous message has a link that has not been clicked | email.</param>
        /// <param name="templateId">the template id already in the system. overrides subject, textBody and htmlBody..</param>
        /// <param name="subject">The subject of the message. Only applies to email messages..</param>
        /// <param name="textBody">The text body of the message..</param>
        /// <param name="htmlBody">The html body of the message. Only applies to email messages..</param>
        public MultiChannelMessageObject(string channel = default(string), int? interval = default(int?), ConditionEnum? condition = default(ConditionEnum?), int? templateId = default(int?), string subject = default(string), string textBody = default(string), string htmlBody = default(string))
        {
            // to ensure "channel" is required (not null)
            if (channel == null)
            {
                throw new InvalidDataException("channel is a required property for MultiChannelMessageObject and cannot be null");
            }
            else
            {
                this.Channel = channel;
            }
            this.Interval = interval;
            this.Condition = condition;
            this.TemplateId = templateId;
            this.Subject = subject;
            this.TextBody = textBody;
            this.HtmlBody = htmlBody;
        }
        
        /// <summary>
        /// Available communications channels in the API. Currently there are Emails and Sms.
        /// </summary>
        /// <value>Available communications channels in the API. Currently there are Emails and Sms.</value>
        [DataMember(Name="channel", EmitDefaultValue=false)]
        public string Channel { get; set; }

        /// <summary>
        /// the interval in seconds between the message and the previous. Defaults to 3600s (1h).
        /// </summary>
        /// <value>the interval in seconds between the message and the previous. Defaults to 3600s (1h).</value>
        [DataMember(Name="interval", EmitDefaultValue=false)]
        public int? Interval { get; set; }


        /// <summary>
        /// the template id already in the system. overrides subject, textBody and htmlBody.
        /// </summary>
        /// <value>the template id already in the system. overrides subject, textBody and htmlBody.</value>
        [DataMember(Name="templateId", EmitDefaultValue=false)]
        public int? TemplateId { get; set; }

        /// <summary>
        /// The subject of the message. Only applies to email messages.
        /// </summary>
        /// <value>The subject of the message. Only applies to email messages.</value>
        [DataMember(Name="subject", EmitDefaultValue=false)]
        public string Subject { get; set; }

        /// <summary>
        /// The text body of the message.
        /// </summary>
        /// <value>The text body of the message.</value>
        [DataMember(Name="textBody", EmitDefaultValue=false)]
        public string TextBody { get; set; }

        /// <summary>
        /// The html body of the message. Only applies to email messages.
        /// </summary>
        /// <value>The html body of the message. Only applies to email messages.</value>
        [DataMember(Name="htmlBody", EmitDefaultValue=false)]
        public string HtmlBody { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class MultiChannelMessageObject {\n");
            sb.Append("  Channel: ").Append(Channel).Append("\n");
            sb.Append("  Interval: ").Append(Interval).Append("\n");
            sb.Append("  Condition: ").Append(Condition).Append("\n");
            sb.Append("  TemplateId: ").Append(TemplateId).Append("\n");
            sb.Append("  Subject: ").Append(Subject).Append("\n");
            sb.Append("  TextBody: ").Append(TextBody).Append("\n");
            sb.Append("  HtmlBody: ").Append(HtmlBody).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as MultiChannelMessageObject);
        }

        /// <summary>
        /// Returns true if MultiChannelMessageObject instances are equal
        /// </summary>
        /// <param name="input">Instance of MultiChannelMessageObject to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MultiChannelMessageObject input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Channel == input.Channel ||
                    (this.Channel != null &&
                    this.Channel.Equals(input.Channel))
                ) && 
                (
                    this.Interval == input.Interval ||
                    (this.Interval != null &&
                    this.Interval.Equals(input.Interval))
                ) && 
                (
                    this.Condition == input.Condition ||
                    (this.Condition != null &&
                    this.Condition.Equals(input.Condition))
                ) && 
                (
                    this.TemplateId == input.TemplateId ||
                    (this.TemplateId != null &&
                    this.TemplateId.Equals(input.TemplateId))
                ) && 
                (
                    this.Subject == input.Subject ||
                    (this.Subject != null &&
                    this.Subject.Equals(input.Subject))
                ) && 
                (
                    this.TextBody == input.TextBody ||
                    (this.TextBody != null &&
                    this.TextBody.Equals(input.TextBody))
                ) && 
                (
                    this.HtmlBody == input.HtmlBody ||
                    (this.HtmlBody != null &&
                    this.HtmlBody.Equals(input.HtmlBody))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Channel != null)
                    hashCode = hashCode * 59 + this.Channel.GetHashCode();
                if (this.Interval != null)
                    hashCode = hashCode * 59 + this.Interval.GetHashCode();
                if (this.Condition != null)
                    hashCode = hashCode * 59 + this.Condition.GetHashCode();
                if (this.TemplateId != null)
                    hashCode = hashCode * 59 + this.TemplateId.GetHashCode();
                if (this.Subject != null)
                    hashCode = hashCode * 59 + this.Subject.GetHashCode();
                if (this.TextBody != null)
                    hashCode = hashCode * 59 + this.TextBody.GetHashCode();
                if (this.HtmlBody != null)
                    hashCode = hashCode * 59 + this.HtmlBody.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
